module Shoulda
  module Matchers
    module ActiveModel
      def allow_values(*values)
        AllowValuesMatcher.new(values)
      end

      # @private
      class AllowValuesMatcher
        delegate :matches?, :does_not_match?, to: :matcher_collection

        def initialize(values)
          if values.empty?
            raise ArgumentError, '#allow_values requires values to test with'
          end

          @values = values
          @matcher_collection = build_matcher_collection
          @qualifiers = {}
        end

        def description
          "be valid when #{attribute} is set to #{formatted_values(values)}"
        end

        def matches?(subject)
          unless qualifiers.key?(:for)
            raise ArgumentError, '#allow_values requires an attribute to test against'
          end

          super(subject)
        end

        def failure_message
        end

        def for(attribute)
          qualifiers[:for] = attribute
          matcher_collection.add_qualifier(:for, attribute)
          self
        end

        def on(context)
          qualifiers[:on] = context
          matcher_collection.add_qualifier(:on, context)
          self
        end

        def strict
          qualifiers[:strict] = true
          matcher_collection.add_qualifier(:strict)
          self
        end

        def with_message(message, options = {})
          qualifiers[:message] = { value: message, options: options }
          matcher_collection.add_qualifier(:with_message, message, options)
          self
        end

        protected

        attr_reader :values, :matcher_collection, :qualifiers

        private

        def build_matcher_collection
          MatcherCollection.new.tap do |matchers|
            values.each do |value|
              matchers.add(AllowValueMatcher, value)
            end
          end
        end

        def formatted_values(values)
          values.to_sentence(
            two_words_connector: ' or ',
            last_word_connector: ', or '
          )
        end
      end
    end
  end
end
